import { GraphQLError, GraphQLSchema, GraphQLDirective, GraphQLEnumType, GraphQLUnionType, GraphQLScalarType, GraphQLInterfaceType, GraphQLInputObjectType, GraphQLObjectType } from 'graphql'
import type { Source, TypeResolverMap, GraphQLOutputType, GraphQLFieldConfig, GraphQLObjectTypeConfig, GraphQLResolveInfo, DocumentNode, UnionTypeDefinitionNode, OperationDefinitionNode, ScalarTypeDefinitionNode, FragmentDefinitionNode, VariableDefinitionNode, SchemaDefinitionNode, GraphQLTypeResolver, GraphQLNamedType, TypeDefinitionNode, GraphQLFieldResolver, ResponsePath, GraphQLField, FieldNode, DirectiveNode, ObjectTypeDefinitionNode, InterfaceTypeDefinitionNode, EnumTypeDefinitionNode, InputObjectTypeDefinitionNode, TypeNode, GraphQLType, GraphQLInputType, ValueNode, DirectiveDefinitionNode, FieldDefinitionNode, InputValueDefinitionNode } from 'graphql'
declare type Thunk<T> = T | () => T
declare module 'graphql-extended' {
/**
 * Flowtype definitions for execute
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Terminology
 * 
"Definitions" are the generic name for top-level statements in the document.
Examples of this include:
1) Operations (such as a query)
2) Fragments

"Operations" are a generic name for requests in the document.
Examples of this include:
1) query,
2) mutation

"Selections" are the definitions that can appear legally and at
single level of the query. These include:
1) field references e.g "a"
2) fragment "spreads" e.g. "...c"
3) inline fragment "spreads" e.g. "...on Type { a }"
*/
declare export interface ExecutionResult {
    data?: {
            [key: string]: mixed
        } | null,
        errors ? :
        Array <
        GraphQLError >
}
declare export type ExecutionConfig = {
    schema: GraphQLSchema,
    document: DocumentNode,
    rootValue?: mixed,
    contextValue?: mixed,
    variableValues?: {
        [key: string]: mixed
    },
    operationName?: string,
    queryReducers?: Array <
        QueryReducer <
        mixed,
    mixed >> ,
    middleware?: Array <
        Middleware <
        mixed,
    mixed,
    mixed >>
};
/**
 * Implements the "Evaluating requests" section of the GraphQL specification.
 * 
Returns a Promise that will eventually be resolved and never rejected.

If the arguments to this function do not result in a legal execution context,
a GraphQLError will be thrown immediately explaining the invalid input.
*/

declare export function execute(config:
    ExecutionConfig):
Promise <
    ExecutionResult>;


/**
 * Given a ResponsePath (found in the `path` entry in the information provided
 * as the last argument to a field resolver), return an Array of the path keys.
 */

declare export function responsePathAsArray(path:
    ResponsePath):
Array<string | number>;

declare export var defaultFieldResolver:
    GraphQLFieldResolver <
    mixed,
    mixed>;

/**
 * Flowtype definitions for ExecutionContext
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Data that must be available at all points during query execution.
 * 
Namely, schema of the type system that is currently executing,
and the fragments defined in the query document
*/
declare export type ExecutionContext = {
    schema: GraphQLSchema,
    fragments: {
        [key: string]: FragmentDefinitionNode
    },
    rootValue: mixed,
    contextValue: mixed,
    operation: OperationDefinitionNode,
    variableValues: {
        [key: string]: mixed
    },
    errors: Array <
        GraphQLError >
};

/**
 * Flowtype definitions for GraphQLExtResolveInfo
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export type GraphQLExtResolveInfo = {
    field: GraphQLField <
        mixed,
    mixed >
} & GraphQLResolveInfo

/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Flowtype definitions for QueryReducer
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export interface QueryReducer<Acc, Ctx>{
    initial: Acc,
    reduceField(parentAcc:
        Acc, childAcc:
        Acc, ctx:
        Ctx, info:
        GraphQLResolveInfo): Acc,
    reduceScalar(path:
        ResponsePath, acc:
        Acc, ctx:
        Ctx): Acc,
    reduceEnum(path:
        ResponsePath, acc:
        Acc, ctx:
        Ctx): Acc,
    reduceCtx(acc:
        Acc, ctx:
        Ctx): Ctx
}

/**
 * Flowtype definitions for values
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Prepares an object map of variableValues of the correct type based on the
 * provided variable definitions and arbitrary input. If the input cannot be
parsed to match the variable definitions, a GraphQLError will be thrown.
*/

declare export function getVariableValues(
    schema:
    GraphQLSchema,
    varDefNodes:
    Array <
    VariableDefinitionNode>,
    inputs: {
        [key: string]: mixed
    }): {
    [key: string]: mixed
};


/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 */

declare export function getArgumentValues(
    def:
    GraphQLField <
    mixed,
    mixed>|
    GraphQLDirective,
    node:
    FieldNode |
    DirectiveNode,
    variableValues?: {
        [key: string]: mixed
    }): {
    [key: string]: mixed
};

/**
 * Flowtype definitions for FactoryMiddleware
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Middleware is useful for manipulating how the SchemaFactory creates a schema.
 * Usage:
  - Provide a class that extends the FactoryMiddleware class to the SchemaFactory.
  - This is implemented as a class instead of an interface so that it can default
    middleware methods to the identity function.
*/
declare export class FactoryMiddleware {

    /**
     * This is called directly before the schema attempts to build and
     * provides an opportunity for any excess setup.
    For example, you might add any default types, interfaces, etc.
     * @param _factory The factory instance calling the middleware
    */
    beforeBuild(_factory:
        SchemaFactory): void;

    /**
     * This is called directly after the schema is built and
     * provides an opportunity for any last second changes.
     * @param schema The GraphQL schema
     */
    afterBuild(schema:
            GraphQLSchema):
        GraphQLSchema;

    /**
     * Allows you to wrap an object type field. Useful for wrapping resolvers
     * @param field The field config. This field may already contain a resolver that was pulled
    from the factories resolver cache. You can choose to override or compose them.
    */
    wrapObjectField(
            _factory:
            SchemaFactory,
            _definition:
            ObjectTypeDefinitionNode,
            field:
            GraphQLFieldConfigExt <
            mixed,
            mixed>):
        GraphQLFieldConfigExt <
        mixed,
        mixed>;

    /**
     * Allows you to wrap an interface type field.
     * @param field The field config. This field may already contain a resolver that was pulled
    from the factories resolver cache. You can choose to override or compose them.
    */
    wrapInterfaceField(
            _factory:
            SchemaFactory,
            _definition:
            InterfaceTypeDefinitionNode,
            field:
            GraphQLFieldConfigExt <
            mixed,
            mixed>):
        GraphQLFieldConfigExt <
        mixed,
        mixed>;

    /**
     * Executed before the schema is built. This is useful for manipulating the
     * AST nodes before they are converted into GraphQL types. Middleware is
    restricted to work on AST nodes instead of types. This is because type members
    are often thunks and it can introduce problems to try to resolve them out of order.
     * @param nodeMap And ImmutableJS Map containing the AST definition nodes.
     * @return  The augmented nodeMap
    */
    wrapObjectNode(
            _factory:
            SchemaFactory,
            definition:
            ObjectTypeDefinitionNode):
        ObjectTypeDefinitionNode;

    /**
     * Wrap an interface or interact with the factory.
     */
    wrapInterfaceNode(
            _factory:
            SchemaFactory,
            definition:
            InterfaceTypeDefinitionNode):
        InterfaceTypeDefinitionNode;

    /**
     * Wrap an enum or interact with the factory.
     */
    wrapEnumNode(
            _factory:
            SchemaFactory,
            definition:
            EnumTypeDefinitionNode):
        EnumTypeDefinitionNode;

    /**
     * Wrap an union or interact with the factory.
     */
    wrapUnionNode(
            _factory:
            SchemaFactory,
            definition:
            UnionTypeDefinitionNode):
        UnionTypeDefinitionNode;

    /**
     * Wrap an scalar or interact with the factory.
     */
    wrapScalarNode(
            _factory:
            SchemaFactory,
            definition:
            ScalarTypeDefinitionNode):
        ScalarTypeDefinitionNode;

    /**
     * Wrap an input or interact with the factory.
     */
    wrapInputNode(
            _factory:
            SchemaFactory,
            definition:
            InputObjectTypeDefinitionNode):
        InputObjectTypeDefinitionNode
}

/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Flowtype definitions for RelayMiddleware
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export var GraphQLCursor:
    GraphQLScalarType;
/**
 * Creates Connection & Edge types for all Node implementing types. This middleware
 * also provides the Node interface, Cursor scalar type, etc.
 */
declare export class RelayMiddleware {
    constructor(resolveNode:
        GraphQLTypeResolver <
        mixed,
        mixed>): this;

    /**
     * Add the Node interface and PageInfo and Cursor types
     */
    beforeBuild(factory:
        SchemaFactory): void;

    /**
     * If the type implements Node then create connection types for it.
     */
    wrapObjectNode(
            factory:
            SchemaFactory,
            definition:
            ObjectTypeDefinitionNode):
        ObjectTypeDefinitionNode;

    /**
     * For each field with a Node implementing type or a wrapper of a Node implementing type
     * such as NonNull or List replace the field with a connection
     */
    wrapObjectField(
            factory:
            SchemaFactory,
            _definition:
            ObjectTypeDefinitionNode,
            field:
            GraphQLFieldConfigExt <
            mixed,
            mixed>):
        GraphQLFieldConfigExt <
        mixed,
        mixed >
}

/**
 * Flowtype definitions for SchemaFactory
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export interface SchemaFactoryConfig {
    middleware ? :
        FactoryMiddleware
}
/**
 * A base class that handles managing and building GraphQL schemas
 */
declare export class SchemaFactory {
    schemaDef:
        SchemaDefinitionNode | null;
    typeMap:
        Map<string,
        GraphQLNamedType>;
    nodeMap:
        Map<string,
        TypeDefinitionNode>;
    resolverMap:
        Map<string,
        FieldResolverMap>;
    typeResolverMap:
        Map<string,
        GraphQLTypeResolver <
        mixed,
        mixed >> ;
    directiveMap:
        Map<string,
        GraphQLDirective>;
    scalarResolvers:
        Map<string,
        ScalarResolverMap <
        mixed,
        mixed >> ;
    constructor(config ? :
        SchemaFactoryConfig): this;
    getSchema():
        GraphQLSchema;
    getType(name: string):
        GraphQLNamedType;
    hasType(name: string): boolean;
    hasDefinition(name: string): boolean;

    /**
     * Getters
     */
    nodes:
        Array <
        TypeDefinitionNode>;
    types:
        Array <
        GraphQLNamedType>;

    /**
     * Add a single object type to the schema.
     * @param spec A single type declaration as GraphQL schema IDL
     * @param resolvers An object with field names for keys and GraphQLFieldResolver functions as values.
     */
    createType(spec: string, resolvers ? :
            FieldResolverMap):
        SchemaFactory;

    /**
     * Add a single interface type to the schema.
     * @param spec A single type declaration as GraphQL schema IDL
     * @param resolveType A GraphQLTypeResolver for the interface
     */
    createInterface(
            spec: string,
            resolveType:
            GraphQLTypeResolver <
            mixed,
            mixed>):
        SchemaFactory;

    /**
     * Add a single enum type to the schema.
     * @param spec A single type declaration as GraphQL schema IDL
     */
    createEnum(spec: string):
        SchemaFactory;

    /**
     * Add a single union type to the schema.
     * @param spec A single type declaration as GraphQL schema IDL
     * @param resolveType A GraphQLTypeResolver for the union
     */
    createUnion(
            spec: string,
            resolveType:
            GraphQLTypeResolver <
            mixed,
            mixed>):
        SchemaFactory;

    /**
     * Extends the factories type cache with prebuilt GraphQL types.
     * @param types 
     */
    extendWithTypes(types:
            Array <
            GraphQLNamedType>):
        SchemaFactory;

    /**
     * Append a GraphQL IDL document to the factory. Any type collisions are resolved
     * via the schema's CollisionResolver.
     * @param spec A GraphQL document string containing the new schema elements
     */
    extendWithSpec(spec: string, resolvers ? :
            TypeResolverMap <
            mixed,
            mixed>):
        SchemaFactory;

    /**
     * Protected API
     * @param directiveNode 
     */
    getDirective(directiveNode:
            DirectiveDefinitionNode):
        GraphQLDirective;
    getObjectTypeNamed(name: string):
        GraphQLObjectType;
    getObjectType(typeNode:
            TypeDefinitionNode):
        GraphQLObjectType;
    produceType(typeNode:
            TypeNode):
        GraphQLType;
    produceInputType(typeNode:
            TypeNode):
        GraphQLInputType;
    produceOutputType(typeNode:
            TypeNode):
        GraphQLOutputType;
    produceObjectType(typeNode:
            TypeNode):
        GraphQLObjectType;
    produceInterfaceType(typeNode:
            TypeNode):
        GraphQLInterfaceType;
    produceDirectiveValue(directiveNode:
            DirectiveNode):
        GraphQLDirectiveValue;
    typeDefNamed(typeName: string):
        GraphQLNamedType;
    makeSchemaDef(
            def:
            TypeDefinitionNode):
        GraphQLObjectType |
        GraphQLInterfaceType |
        GraphQLEnumType |
        GraphQLUnionType |
        GraphQLInputObjectType |
        GraphQLScalarType;
    makeTypeDef(def:
            ObjectTypeDefinitionNode):
        GraphQLObjectType;
    getResolver(
            type:
            ObjectTypeDefinitionNode,
            field:
            FieldDefinitionNode):
        GraphQLFieldResolver <
        mixed,
        mixed>;
    makeObjectFieldDefMap(def:
            ObjectTypeDefinitionNode):
        GraphQLFieldConfigMapExt <
        mixed,
        mixed>;
    makeInterfaceFieldDefMap(def:
            InterfaceTypeDefinitionNode):
        GraphQLFieldConfigMapExt <
        mixed,
        mixed>;
    makeImplementedInterfaces(def:
            ObjectTypeDefinitionNode):
        Array <
        GraphQLInterfaceType>;
    makeDirectiveValues(
            def:
            ObjectTypeDefinitionNode |
            FieldDefinitionNode):
        Array <
        GraphQLDirectiveValue>;
    makeInputValues(values:
        Array <
        InputValueDefinitionNode>): {
        [name: string]: mixed
    };
    makeInterfaceDef(def:
            InterfaceTypeDefinitionNode):
        GraphQLInterfaceType;
    makeEnumDef(def:
            EnumTypeDefinitionNode):
        GraphQLEnumType;
    makeUnionDef(def:
            UnionTypeDefinitionNode):
        GraphQLUnionType;
    makeScalarDef(def:
            ScalarTypeDefinitionNode):
        GraphQLScalarType;
    makeInputObjectDef(def:
            InputObjectTypeDefinitionNode):
        GraphQLInputObjectType
}

/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Flowtype definitions for find
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

declare export default function find<T>(collection:
        Array <
        T>, condition: (val:
            T) => boolean):
    T | null;

/**
 * Flowtype definitions for invariant
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

declare export default function invariant(condition:
    mixed, message: string): void;

/**
 * Flowtype definitions for isInvalid
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree. An additional grant
of patent rights can be found in the PATENTS file in the same directory.Returns true if a value is undefined, or NaN.
*/

declare export default function isInvalid(value:
    mixed): boolean;

/**
 * Flowtype definitions for isNullish
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree. An additional grant
of patent rights can be found in the PATENTS file in the same directory.Returns true if a value is null, undefined, or NaN.
*/

declare export default function isNullish(value:
    mixed): boolean;

/**
 * Flowtype definitions for keyMap
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree. An additional grant
of patent rights can be found in the PATENTS file in the same directory.Creates a keyed JS object from an array, given a function to produce the keys
 * for each value in the array.

This provides a convenient lookup for the array items if the key function
produces unique results.

     const phoneBook = [
       { name: 'Jon', num: '555-1234' },
       { name: 'Jenny', num: '867-5309' }
     ]

     // { Jon: { name: 'Jon', num: '555-1234' },
     //   Jenny: { name: 'Jenny', num: '867-5309' } }
     const entriesByName = keyMap(
       phoneBook,
       entry => entry.name
     )

     // { name: 'Jenny', num: '857-6309' }
     const jennyEntry = entriesByName['Jenny']
*/

declare export default function keyMap<T>(list:
    Array <
    T>, keyFn: (item:
        T) => string): {
    [key: string]: T
};

/**
 * Flowtype definitions for keyValMap
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

declare export default function keyValMap<T, V>(
    list:
    Array <
    T>,
    keyFn: (item:
        T) => string,
    valFn: (item:
        T) =>
    V): {
    [key: string]: V
};

/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Flowtype definitions for Middleware
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export interface Middleware<MiddlewareValue, FieldValue, Ctx>{

    /**
     * Runs immediately before a query is executed. Returns a MiddlewareValue that serves as
     * context for this specific middleware function.
     */
    beforeQuery(context:
        ExecutionContext): MiddlewareValue,

    /**
     * Runs immediately after a query is executed. mVal contains the middleware value
     * accumulated by this middleware.
     */
    afterQuery(mVal:
        MiddlewareValue, mctx:
        ExecutionContext): void,

    /**
     * Run for each field directly before field resolution.
     * @return  Returns a tuple containing a FieldValue and an optional resolution value.
    If beforeField returns a second value in the tuple, that is the result of the
    execution. This is convenient for cache checking for example.
    */
    beforeField(
        mVal:
        MiddlewareValue,
        eCtx:
        ExecutionContext,
        mCtx:
        ResolverContext <
        Ctx>): FieldValue,

    /**
     * Run for each field directly after field resolution.
     * 
    Returning a value from this method will change the output for the resolution
    */
    afterField(
        mVal:
        MiddlewareValue,
        fVal:
        FieldValue,
        value:
        mixed,
        eCtx:
        ExecutionContext,
        mCtx:
        ResolverContext <
        Ctx>): mixed
}
declare export interface ResolverContext<Ctx>{
    source: mixed,
    args: mixed,
    context: Ctx,
    info: GraphQLExtResolveInfo
}

/**
 * Flowtype definitions for ResolverTimer
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export type FieldTimerTimeUnit = 'milli' | 'micro' | 'nano';
declare export class ResolverTimer {
    constructor(logger: (
            totalRunTime: number,
            resolverDurationMap:
            Map<string, number>) =>
        mixed | void, timeUnit ? :
        FieldTimerTimeUnit): this;
    beforeQuery():
        Map<string, number>;
    beforeField(): number;
    afterField(
        mVal:
        Map<string, number>,
        fValue: number,
        _value:
        mixed,
        _eCtx:
        ExecutionContext,
        mCtx:
        ResolverContext <
        mixed>): void;
    afterQuery(mVal:
        Map<string, number>): void
}

/**
 * Flowtype definitions for Suffixer
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export class Suffixer {
    constructor(suffix: string): this;
    beforeQuery():
        Map<string, number>;
    afterField(
        _mVal:
        Map<string, number>,
        _fValue: number,
        value:
        mixed,
        _eCtx:
        ExecutionContext,
        mCtx:
        ResolverContext <
        mixed>): string | void
}

/**
 * Flowtype definitions for ComplexityReducer
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export default class ComplexityReducer {
    initial: number;
    constructor(): this;
    reduceField(parent: number, child: number): number;
    reduceScalar(): number;
    reduceEnum(): number;
    reduceCtx(acc: number, ctx:
            Object):
        Object
}

/**
 * Flowtype definitions for DirectiveCollector
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export default class DirectiveCollector<ReducedDirective>{
    initial: Array <
        ReducedDirective>;
    constructor(handleDirective: (directive:
            GraphQLDirectiveValue) =>
        ReducedDirective, reduceContext: (acc:
            Array <
            ReducedDirective>, ctx:
            Object) =>
        Object): this;
    reduceField(
        parent:
        Array <
        ReducedDirective>,
        child:
        Array <
        ReducedDirective>,
        _ctx:
        mixed,
        info:
        GraphQLExtResolveInfo): Array <
        ReducedDirective>;
    reduceScalar(): Array <
        ReducedDirective>;
    reduceEnum(): Array <
        ReducedDirective>;
    reduceCtx(acc:
        Array <
        ReducedDirective>, ctx:
        Object): Object
}

/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Flowtype definitions for CompositeResolver
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export type ComposableResolver<TSource, TOutput>= (
        fn:
        GraphQLFieldResolver <
        TSource,
        TOutput>) =>
    GraphQLFieldResolver <
    TSource,
    TOutput>;
declare export function compose<TSource, TOutput>(
        ...funcs:
        Array <
        ComposableResolver <
        TSource,
        TOutput >> ):
    ComposableResolver <
    TSource,
    TOutput>;


declare export function CompositeResolver<TSource, TOutput>(
        ...funcs:
        Array <
        ComposableResolver <
        TSource,
        TOutput >> ): (
        resolver:
        GraphQLFieldResolver <
        TSource,
        TOutput>) =>
    GraphQLFieldResolver <
    TSource,
    TOutput>;

/**
 * Flowtype definitions for Identity
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

declare export function Identity(source:
    mixed, _a:
    mixed, _c:
    mixed, info:
    GraphQLResolveInfo):
mixed;

/**
 * Flowtype definitions for directives
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * A decorator is directive specified on the schema.
 */
declare export type GraphQLDirectiveValueConfig = {
    name: string,
    description?: string,
    args: {
        [name: string]: mixed
    }
};
declare export class GraphQLDirectiveValue {
    name: string;
    args: {
        [name: string]: mixed
    };
    constructor(config:
        GraphQLDirectiveValueConfig): this;
    get(key: string):
        mixed
}
declare export var RelationKind: {
    HAS_MANY: string,
    HAS_ONE: string,
    BELONGS_TO: string,
    BELONGS_TO_MANY: string
};
declare export var GraphQLRelationDirective:
    GraphQLDirective;

/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Flowtype definitions for object
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export type GraphQLObjectTypeConfigExt<TSource, TContext>= {
    directives?: Thunk <
        Array <
        GraphQLDirectiveValue >>
} & GraphQLObjectTypeConfig
declare export interface GraphQLFieldConfigMapExt<TSource, TContext>{
    [fieldName: string]: GraphQLFieldConfigExt <
        TSource,
    TContext >
}
declare export type GraphQLFieldConfigExt<TSource, TContext>= {
    directives: Array <
        GraphQLDirectiveValue >
} & GraphQLFieldConfig
declare export type GraphQLFieldExt<TSource, TContext>= {
    directives: Array <
        GraphQLDirectiveValue >
} & GraphQLField

/**
 * The schemata is an extension of a GraphQLSchema that includes extra
 * functionality to merge schemas, manage directives, and more.

Schemata Definition

A Schema is created by supplying the root types of each type of operation,
query and mutation (optional). A schema definition is then supplied to the
validator and executor.

Example:

     const MyAppSchema = new GraphQLSchema({
       query: MyAppQueryRootType,
       mutation: MyAppMutationRootType,
     })

Note: If an array of `directives` are provided to GraphQLSchema, that will be
the exact list of directives represented and allowed. If `directives` is not
provided then a default set of the specified directives (e.g. @include and
 * @skip  ) will be used. If you wish to provide *additional* directives to these
specified directives, you must explicitly declare them. Example:

const MyAppSchema = new GraphQLSchema({
  ...
  directives: specifiedDecorators.concat([ myCustomDirective ]),
})
*/
declare export class GraphQLObjectTypeExt {
    constructor(config:
        GraphQLObjectTypeConfigExt <
        mixed,
        mixed>): this;
    getDirectives():
        Array <
        GraphQLDirectiveValue >
}

/**
 * Flowtype definitions for schema
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export type GraphQLSchemaExtConfig = {
    query: GraphQLObjectType,
    mutation?: GraphQLObjectType,
    subscription?: GraphQLObjectType,
    types?: Array <
        GraphQLNamedType>,
    directives?: Array <
        GraphQLDirective >
};
/**
 * The schemata is an extension of a GraphQLSchema that includes extra
 * functionality to merge schemas, manage directives, and more.

Schemata Definition

A Schema is created by supplying the root types of each type of operation,
query and mutation (optional). A schema definition is then supplied to the
validator and executor.

Example:

     const MyAppSchema = new GraphQLSchema({
       query: MyAppQueryRootType,
       mutation: MyAppMutationRootType,
     })

Note: If an array of `directives` are provided to GraphQLSchema, that will be
the exact list of directives represented and allowed. If `directives` is not
provided then a default set of the specified directives (e.g. @include and
 * @skip  ) will be used. If you wish to provide *additional* directives to these
specified directives, you must explicitly declare them. Example:

const MyAppSchema = new GraphQLSchema({
  ...
  directives: specifiedDirectives.concat([ myCustomDirective ]),
})
*/
declare export class GraphQLSchemaExt {
    constructor(config:
        GraphQLSchemaExtConfig): this;
    extend(spec: string): void
}

/**
 * Flowtype definitions for asyncReduce
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

declare export function asyncReduce<Acc, T>(
        reducer: (acc:
            Promise <
            Acc>, elem:
            T, ind: number) =>
        Promise <
        Acc>,
        initialValue:
        Promise <
        Acc>,
        iterable:
        Array <
        T>):
    Promise <
    Acc>;

/**
 * Flowtype definitions for buildASTSchema
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * This takes the ast of a schema document produced by the parse function in
 * src/language/parser.js.

If no schema definition is provided, then it will look for types named Query
and Mutation.

Given that AST it constructs a GraphQLSchema. The resulting schema
has no resolve methods, so execution will use default resolvers.
*/

declare export function buildASTSchema(
    ast:
    DocumentNode,
    resolverMap ? :
    TypeResolverMap <
    mixed,
    mixed>):
GraphQLSchema;


/**
 * Given a collection of directives, returns the string value for the
 * deprecation reason.
 */

declare export function getDeprecationReason(directives ? :
    Array <
    DirectiveNode>): string | void;


/**
 * Given an ast node, returns its string description based on a contiguous
 * block full-line of comments preceding it.
 */

declare export function getDescription(node: {
    loc?: Location
}): string | void;


/**
 * A helper function to build a GraphQLSchema directly from a source
 * document.
 */

declare export function buildSchema(source: string |
    Source):
GraphQLSchema;

/**
 * Flowtype definitions for getDeprecationReason
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Given a collection of directives, returns the string value for the
 * deprecation reason.
 */

declare export function getDeprecationReason(directives ? :
    Array <
    DirectiveNode>): string | void;

/**
 * Flowtype definitions for getDescription
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Given an ast node, returns its string description based on a contiguous
 * block full-line of comments preceding it.
 */

declare export function getDescription(node: {
    loc?: Location
}): string | void;

/**
 * Flowtype definitions for getNamedOutputType
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export type GraphQLNamedOutputType =
    GraphQLScalarType |
    GraphQLObjectType |
    GraphQLInterfaceType |
    GraphQLUnionType |
    GraphQLEnumType;
/**
 * Given a GraphQLOutputType returns the underlying Object, Scalar, Union, Interface, or Enum.
 * @param type 
 */

declare export function getNamedOutputType(type:
    GraphQLOutputType):
GraphQLNamedOutputType;

/**
 * Flowtype definitions for implementsInterface
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

declare export function implementsInterface(type:
    GraphQLOutputType, interfaceName: string): boolean;

/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Flowtype definitions for isListType
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

declare export function isListType(type:
    GraphQLOutputType): boolean;

/**
 * Flowtype definitions for leadingSpaces
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

declare export function leadingSpaces(str: string): number;

/**
 * Flowtype definitions for nodeImplementsInterface
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

declare export function nodeImplementsInterface(node:
    TypeDefinitionNode, interfaceName: string): boolean;

/**
 * Flowtype definitions for ResolverMap
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * For each object type
 */
declare export type TypeResolverMap<TSource, TContext>= {
    [typeName: string]: {
        [fieldName: string]: GraphQLFieldResolver <
            TSource,
        TContext >
    }
};
declare export type FieldResolverMap = {
    [fieldName: string]: GraphQLFieldResolver <
        mixed,
    mixed >
};
declare export type ScalarResolver<TInternal, TExternal>= {
    serialize: (value:
            mixed) =>
        TExternal | null,
    parseValue?: (value:
            mixed) =>
        TInternal | null,
    parseLiteral?: (valueAST:
            ValueNode) =>
        TInternal | null
};
declare export type ScalarResolverMap<TInternal, TExternal>= {
    [scalarName: string]: ScalarResolver <
        TInternal,
    TExternal >
};

}
