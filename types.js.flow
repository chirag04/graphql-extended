import { GraphQLError, GraphQLSchema, GraphQLDirective, GraphQLEnumType, GraphQLUnionType, GraphQLScalarType, GraphQLInterfaceType, GraphQLInputObjectType, GraphQLObjectType } from 'graphql'
import type { Source, TypeResolverMap, GraphQLOutputType, GraphQLFieldConfig, GraphQLObjectTypeConfig, GraphQLResolveInfo, DocumentNode, UnionTypeDefinitionNode, OperationDefinitionNode, ScalarTypeDefinitionNode, FragmentDefinitionNode, VariableDefinitionNode, SchemaDefinitionNode, GraphQLTypeResolver, GraphQLNamedType, TypeDefinitionNode, GraphQLFieldResolver, ResponsePath, GraphQLField, FieldNode, DirectiveNode, ObjectTypeDefinitionNode, InterfaceTypeDefinitionNode, EnumTypeDefinitionNode, InputObjectTypeDefinitionNode, TypeNode, GraphQLType, GraphQLInputType, ValueNode, DirectiveDefinitionNode, FieldDefinitionNode, InputValueDefinitionNode } from 'graphql'
declare type Thunk<T> = T | () => T
declare module 'graphql-extended' {
/**
 * Flowtype definitions for execute
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Terminology
 * 
"Definitions" are the generic name for top-level statements in the document.
Examples of this include:
1) Operations (such as a query)
2) Fragments

"Operations" are a generic name for requests in the document.
Examples of this include:
1) query,
2) mutation

"Selections" are the definitions that can appear legally and at
single level of the query. These include:
1) field references e.g "a"
2) fragment "spreads" e.g. "...c"
3) inline fragment "spreads" e.g. "...on Type { a }"
*/
declare export interface ExecutionResult {
    data?: {
            [key: string]: mixed
        } | null,
        errors ? :
        Array <
        GraphQLError >
}
declare export type ExecutionConfig = {
    schema: GraphQLSchema,
    document: DocumentNode,
    rootValue?: mixed,
    contextValue?: mixed,
    variableValues?: {
        [key: string]: mixed
    },
    operationName?: string,
    queryReducers?: Array <
        QueryReducer <
        mixed,
    mixed >> ,
    middleware?: Array <
        Middleware <
        mixed,
    mixed,
    mixed >>
};
/**
 * Implements the "Evaluating requests" section of the GraphQL specification.
 * 
Returns a Promise that will eventually be resolved and never rejected.

If the arguments to this function do not result in a legal execution context,
a GraphQLError will be thrown immediately explaining the invalid input.
*/

declare export function execute(config:
    ExecutionConfig):
Promise <
    ExecutionResult>;


/**
 * Given a ResponsePath (found in the `path` entry in the information provided
 * as the last argument to a field resolver), return an Array of the path keys.
 */

declare export function responsePathAsArray(path:
    ResponsePath):
Array<string | number>;

declare export var defaultFieldResolver:
    GraphQLFieldResolver <
    mixed,
    mixed>;

/**
 * Flowtype definitions for ExecutionContext
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Data that must be available at all points during query execution.
 * 
Namely, schema of the type system that is currently executing,
and the fragments defined in the query document
*/
declare export type ExecutionContext = {
    schema: GraphQLSchema,
    fragments: {
        [key: string]: FragmentDefinitionNode
    },
    rootValue: mixed,
    contextValue: mixed,
    operation: OperationDefinitionNode,
    variableValues: {
        [key: string]: mixed
    },
    errors: Array <
        GraphQLError >
};

/**
 * Flowtype definitions for GraphQLExtResolveInfo
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export type GraphQLExtResolveInfo = {
    field: GraphQLField <
        mixed,
    mixed >
} & GraphQLResolveInfo

/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Flowtype definitions for QueryReducer
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export interface QueryReducer<Acc, Ctx>{
    initial: Acc,
    reduceField(parentAcc:
        Acc, childAcc:
        Acc, ctx:
        Ctx, info:
        GraphQLResolveInfo): Acc,
    reduceScalar(path:
        ResponsePath, acc:
        Acc, ctx:
        Ctx): Acc,
    reduceEnum(path:
        ResponsePath, acc:
        Acc, ctx:
        Ctx): Acc,
    reduceCtx(acc:
        Acc, ctx:
        Ctx): Ctx
}

/**
 * Flowtype definitions for values
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Prepares an object map of variableValues of the correct type based on the
 * provided variable definitions and arbitrary input. If the input cannot be
parsed to match the variable definitions, a GraphQLError will be thrown.
*/

declare export function getVariableValues(
    schema:
    GraphQLSchema,
    varDefNodes:
    Array <
    VariableDefinitionNode>,
    inputs: {
        [key: string]: mixed
    }): {
    [key: string]: mixed
};


/**
 * Prepares an object map of argument values given a list of argument
 * definitions and list of argument AST nodes.
 */

declare export function getArgumentValues(
    def:
    GraphQLField <
    mixed,
    mixed>|
    GraphQLDirective,
    node:
    FieldNode |
    DirectiveNode,
    variableValues?: {
        [key: string]: mixed
    }): {
    [key: string]: mixed
};

/**
 * Flowtype definitions for FactoryMiddleware
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Middleware is useful for manipulating how the SchemaFactory creates a schema.
 * Usage:
  - Provide a class that extends the FactoryMiddleware class to the SchemaFactory.
  - This is implemented as a class instead of an interface so that it can default
    middleware methods to the identity function.
*/
declare export class FactoryMiddleware {

    /**
     * This is called directly before the schema attempts to build and
     * provides an opportunity for any excess setup.
    For example, you might add any default types, interfaces, etc.
     * @param _factory The factory instance calling the middleware
    */
    onInit(_factory:
        SchemaFactory): void;

    /**
     * This is called immediately after getSchema() is called and
     * provides an opportunity for any excess setup.
    For example, you might add any default types, interfaces, etc.
     * @param _factory The factory instance calling the middleware
    */
    beforeBuild(_factory:
        SchemaFactory): void;

    /**
     * This is called directly after the schema is built and
     * provides an opportunity for any last second changes.
     * @param schema The GraphQL schema
     */
    afterBuild(schema:
            GraphQLSchema):
        GraphQLSchema;

    /**
     * Allows you to wrap an object type field. Useful for wrapping resolvers
     * @param field The field config. This field may already contain a resolver that was pulled
    from the factories resolver cache. You can choose to override or compose them.
    */
    wrapObjectField(
            _factory:
            SchemaFactory,
            _definition:
            ObjectTypeDefinitionNode,
            field:
            GraphQLFieldConfigExt <
            mixed,
            mixed>):
        GraphQLFieldConfigExt <
        mixed,
        mixed>;

    /**
     * Allows you to wrap an interface type field.
     * @param field The field config. This field may already contain a resolver that was pulled
    from the factories resolver cache. You can choose to override or compose them.
    */
    wrapInterfaceField(
            _factory:
            SchemaFactory,
            _definition:
            InterfaceTypeDefinitionNode,
            field:
            GraphQLFieldConfigExt <
            mixed,
            mixed>):
        GraphQLFieldConfigExt <
        mixed,
        mixed>;

    /**
     * Executed before the schema is built. This is useful for manipulating the
     * AST nodes before they are converted into GraphQL types. These middleware methods
    operate on the AST nodes before they are built into full GraphQL types.
     * @param nodeMap And ImmutableJS Map containing the AST definition nodes.
     * @return  The augmented nodeMap
    */
    wrapObjectNode(
            _factory:
            SchemaFactory,
            definition:
            ObjectTypeDefinitionNode):
        ObjectTypeDefinitionNode;

    /**
     * Wrap an interface or interact with the factory.
     */
    wrapInterfaceNode(
            _factory:
            SchemaFactory,
            definition:
            InterfaceTypeDefinitionNode):
        InterfaceTypeDefinitionNode;

    /**
     * Wrap an enum or interact with the factory.
     */
    wrapEnumNode(
            _factory:
            SchemaFactory,
            definition:
            EnumTypeDefinitionNode):
        EnumTypeDefinitionNode;

    /**
     * Wrap an union or interact with the factory.
     */
    wrapUnionNode(
            _factory:
            SchemaFactory,
            definition:
            UnionTypeDefinitionNode):
        UnionTypeDefinitionNode;

    /**
     * Wrap an scalar or interact with the factory.
     */
    wrapScalarNode(
            _factory:
            SchemaFactory,
            definition:
            ScalarTypeDefinitionNode):
        ScalarTypeDefinitionNode;

    /**
     * Wrap an input or interact with the factory.
     */
    wrapInputNode(
            _factory:
            SchemaFactory,
            definition:
            InputObjectTypeDefinitionNode):
        InputObjectTypeDefinitionNode;

    /**
     * Executed before the schema is built. This is useful for manipulating the GraphQL types before
     * they are committed to the factory cache.
     * @param nodeMap And ImmutableJS Map containing the AST definition nodes.
     * @return  The augmented nodeMap
     */
    wrapObjectType(
            _factory:
            SchemaFactory,
            _definition:
            ObjectTypeDefinitionNode,
            object:
            GraphQLObjectTypeExt):
        GraphQLObjectTypeExt;

    /**
     * Wrap an interface type or interact with the factory.
     */
    wrapInterfaceType(
            _factory:
            SchemaFactory,
            _definition:
            InterfaceTypeDefinitionNode,
            interfce:
            GraphQLInterfaceType):
        GraphQLInterfaceType;

    /**
     * Wrap an enum type or interact with the factory.
     */
    wrapEnumType(
            _factory:
            SchemaFactory,
            _definition:
            EnumTypeDefinitionNode,
            enm:
            GraphQLEnumType):
        GraphQLEnumType;

    /**
     * Wrap an union type or interact with the factory.
     */
    wrapUnionType(
            _factory:
            SchemaFactory,
            _definition:
            UnionTypeDefinitionNode,
            union:
            GraphQLUnionType):
        GraphQLUnionType;

    /**
     * Wrap an scalar type or interact with the factory.
     */
    wrapScalarType(
            _factory:
            SchemaFactory,
            _definition:
            ScalarTypeDefinitionNode,
            sclr:
            GraphQLScalarType):
        GraphQLScalarType;

    /**
     * Wrap an input type or interact with the factory.
     */
    wrapInputType(
            _factory:
            SchemaFactory,
            _definition:
            InputObjectTypeDefinitionNode,
            inpt:
            GraphQLInputObjectType):
        GraphQLInputObjectType
}

/**
 * Flowtype definitions for index
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */

/**
 * Flowtype definitions for RelayMiddleware
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export var GraphQLCursor:
    GraphQLScalarType;
/**
 * Creates Connection & Edge types for all Node implementing types. This middleware
 * also provides the Node interface, Cursor scalar type, etc.
 */
declare export class RelayMiddleware {
    constructor(resolveNode:
        GraphQLTypeResolver <
        mixed,
        mixed>): this;

    /**
     * Add the Node interface and PageInfo and Cursor types
     */
    beforeBuild(factory:
        SchemaFactory): void;

    /**
     * If the type implements Node then create connection types for it.
     */
    wrapObjectNode(
            factory:
            SchemaFactory,
            definition:
            ObjectTypeDefinitionNode):
        ObjectTypeDefinitionNode;

    /**
     * For each field with a Node implementing type or a wrapper of a Node implementing type
     * such as NonNull or List replace the field with a connection
     */
    wrapObjectField(
            factory:
            SchemaFactory,
            _definition:
            ObjectTypeDefinitionNode,
            field:
            GraphQLFieldConfigExt <
            mixed,
            mixed>):
        GraphQLFieldConfigExt <
        mixed,
        mixed >
}

/**
 * Flowtype definitions for SchemaFactory
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 */
declare export interface SchemaFactoryConfig {
    middleware ? :
        FactoryMiddleware,
        onResolverCollision?: (
            oldFn:
            FieldResolverMap,
            newFn:
            FieldResolverMap,
            key: string) =>
        FieldResolverMap,
        onTypeCollision?: (
            oldType:
            GraphQLNamedType,
            newType:
            GraphQLNamedType,
            key: string) =>
        GraphQLNamedType
}
/**
 * A base class that handles managing and building GraphQL schemas
 */
declare export class SchemaFactory {
    schemaDef:
        SchemaDefinitionNode | null;
    typeMap:
        Map<string,
        GraphQLNamedType>;
    nodeMap:
        Map<string,
        TypeDefinitionNode>;
    resolverMap:
        Map<string,
        FieldResolverMap>;
    typeResolverMap:
        Map<string,
        GraphQLTypeResolver <
        mixed,
        mixed >> ;
    directiveMap:
        Map<string,
        GraphQLDirective>;
    scalarResolvers:
        Map<string,
        ScalarResolverMap <
        mixed,
        mixed >> ;
    constructor(config ? :
        SchemaFactoryConfig): this;
    getSchema():
        GraphQLSchema;
    getType(name: string):
        GraphQLNamedType;
    hasType(name: string): boolean;
    hasDefinition(name: string): boolean;

    /**
     * Getters
     */
    nodes:
        Array <
        TypeDefinitionNode>;
    types:
        Array <
        GraphQLNamedType>;

    /**
     * Add resolvers to the resolver map. These resolvers will get merged into types
     * when you call getSchema().
     */
    addResolveFunctionsToSchema(resolvers ? :
            TypeResolverMap <
            mixed,
            mixed>):
        SchemaFactory;

    /**
     * Add a single object type to the schema.
     * @param spec A single type declaration as GraphQL schema IDL
     * @param resolvers An object with field names for keys and GraphQLFieldResolver functions as values.
     */
    createType(spec: string, resolvers ? :
            FieldResolverMap):
        SchemaFactory;

    /**
     * Add a single interface type to the schema.
     * @param spec A single type declaration as GraphQL schema IDL
     * @param resolveType A GraphQLTypeResolver for the interface
     */
    createInterface(
            spec: string,
            resolveType:
            GraphQLTypeResolver <
            mixed,
            mixed>):
        SchemaFactory;

    /**
     * Add a single enum type to the schema.
     * @param spec A single type declaration as GraphQL schema IDL
     */
    createEnum(spec: string):
        SchemaFactory;

    /**
     * Add a single union type to the schema.
     * @param spec A single type declaration as GraphQL schema IDL
     * @param resolveType A GraphQLTypeResolver for the union
     */
    createUnion(
            spec: string,
            resolveType:
            GraphQLTypeResolver <
            mixed,
            mixed>):
        SchemaFactory;

    /**
     * Extends the factories type cache with prebuilt GraphQL types.
     * @param types 
     */
    extendWithTypes(types:
            Array <
            GraphQLNamedType>):
        SchemaFactory;

    /**
     * Append a GraphQL IDL document to the factory. Any type collisions are resolved
     * via the schema's CollisionResolver.
     * @param spec A GraphQL document string containing the new schema elements
     */
    extendWithSpec(spec: string, resolvers ? :
            TypeResolverMap <
            mixed,
            mixed>):
        SchemaFactory;

    /**
     * Protected API
     * @param directiveNode 
     */
    getDirective(directiveNode:
            DirectiveDefinitionNode):
        GraphQLDirective;
    getObjectTypeNamed(name: string):
        GraphQLObjectType;
    getObjectType(typeNode:
            TypeDefinitionNode):
        GraphQLObjectType;
    produceType(typeNode:
            TypeNode):
        GraphQLType;
    produceInputType(typeNode:
            TypeNode):
        GraphQLInputType;
    produceOutputType(typeNode:
            TypeNode):
        GraphQLOutputType;
    produceObjectType(typeNode:
            TypeNode):
        GraphQLObjectType;
    produceInterfaceType(typeNode:
            TypeNode):
        GraphQLInterfaceType;
    produceDirectiveValue(directiveNode:
            DirectiveNode):
        GraphQLDirectiveValue;
    typeDefNamed(typeName: string):
        GraphQLNamedType;
    makeSchemaDef(
            def:
            TypeDefinitionNode):
        GraphQLObjectType |
        GraphQLInterfaceType |
        GraphQLEnumType |
        GraphQLUnionType |
        GraphQLInputObjectType |
        GraphQLScalarType;
    makeTypeDef(def:
            ObjectTypeDefinitionNode):
        GraphQLObjectType;
    getResolver(
            type:
            ObjectTypeDefinitionNode,
            field:
            FieldDefinitionNode):
        GraphQLFieldResolver <
        mixed,
        mixed>;
    makeObjectFieldDefMap(def:
            ObjectTypeDefinitionNode):
        GraphQLFieldConfigMapExt <
        mixed,
        mixed>;
    makeInterfaceFieldDefMap(def:
            InterfaceTypeDefinitionNode):
        GraphQLFieldConfigMapExt <
        mixed,
        mixed>;
    makeImplementedInterfaces(def:
            ObjectTypeDefinitionNode):
        Array <
        GraphQLInterfaceType>;
    makeDirectiveValues(
            def:
            ObjectTypeDefinitionNode |
            FieldDefinitionNode):
        Array <
        GraphQLDirectiveValue>;
    makeInputValues(values:
        Array <
        InputValueDefinitionNode>): {
        [name: string]: mixed
    };
    makeInterfaceDef(def:
            InterfaceTypeDefinitionNode):
        GraphQLInterfaceType;
    makeEnumDef(def:
            EnumTypeDefinitionNode):
        GraphQLEnumType;
    makeUnionDef(def:
            UnionTypeDefinitionNode):
        GraphQLUnionType;
    makeScalarDef(def:
            ScalarTypeDefinitionNode):
        GraphQLScalarType;
    makeInputObjectDef(def:
            InputObjectTypeDefinitionNode):
        GraphQLInputObjectType
}

