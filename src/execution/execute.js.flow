/* @flow */
/**
 * Flowtype definitions for execu
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.2.0
 * Repo: https://github.com/scaphold-io/flowgen
 */

import {
    forEach,
    isCollection
} from 'iterall';
import {
    GraphQLError,
    locatedError
} from 'graphql/error';
import find from '../jsutils/find';
import invariant from '../jsutils/invariant';
import isNullish from '../jsutils/isNullish';
import {
    typeFromAST
} from 'graphql/utilities/typeFromAST';
import * as Kind from 'graphql/language/kinds';
import {
    getVariableValues,
    getArgumentValues
} from './values';
import {
    GraphQLSchema,
    GraphQLEnumType,
    GraphQLObjectType,
    GraphQLList,
    GraphQLNonNull,
    GraphQLInterfaceType,
    GraphQLUnionType,
} from 'graphql'
import type {
    GraphQLType,
    GraphQLLeafType,
    GraphQLAbstractType,
    GraphQLField,
    GraphQLFieldResolver,
    GraphQLResolveInfo,
    ResponsePath,
    GraphQLScalarType,
    isAbstractType,
    GraphQLOutputType
} from 'graphql/type';
import {
    SchemaMetaFieldDef,
    TypeMetaFieldDef,
    TypeNameMetaFieldDef
} from 'graphql/type/introspection';
import {
    GraphQLIncludeDirective,
    GraphQLSkipDirective
} from 'graphql/type/directives';
import type {
    DirectiveNode,
    DocumentNode,
    OperationDefinitionNode,
    SelectionSetNode,
    FieldNode,
    InlineFragmentNode,
    FragmentDefinitionNode
} from 'graphql/language/ast';
import {
    QueryReducer
} from './QueryReducer';
import {
    Middleware
} from '../middleware/Middleware';
import type {
    ExecutionContext
} from './ExecutionContext';
import type {
    GraphQLExtResolveInfo
} from './GraphQLExtResolveInfo';

declare type MaybePromise<T> = Promise<T> | T

/**
 * Terminology
 *
"Definitions" are the generic name for top-level statements in the document.
Examples of this include:
1) Operations (such as a query)
2) Fragments

"Operations" are a generic name for requests in the document.
Examples of this include:
1) query,
2) mutation

"Selections" are the definitions that can appear legally and at
single level of the query. These include:
1) field references e.g "a"
2) fragment "spreads" e.g. "...c"
3) inline fragment "spreads" e.g. "...on Type { a }"
*/
export interface ExecutionResult {
    data?: {
            [key: string]: mixed
        } | null,
        errors?: Array<GraphQLError >
}
/**
 * All information needed for middleware to function
 */
type MiddlewareContext = {
    middleware: Array<Middleware<mixed,
    mixed,
    mixed >> ,
    middlewareValues: Array<mixed >
};
export type ExecutionConfig = {
    schema: GraphQLSchema,
    document: DocumentNode,
    rootValue?: mixed,
    contextValue?: mixed,
    variableValues?: {
        [key: string]: mixed
    },
    operationName?: string,
    queryReducers?: Array<QueryReducer<mixed,
    mixed >> ,
    middleware?: Array<Middleware<mixed,
    mixed,
    mixed >>
};
/**
 * Implements the "Evaluating requests" section of the GraphQL specification.
 *
Returns a Promise that will eventually be resolved and never rejected.

If the arguments to this function do not result in a legal execution context,
a GraphQLError will be thrown immediately explaining the invalid input.
*/
declare export function execute(config: ExecutionConfig): Promise<ExecutionResult>;
declare function reduceQueryIfNeeded(
    queryReducers: Array<QueryReducer<mixed, mixed >> ,
    context: ExecutionContext): Promise<ExecutionContext>;
declare function reduceQuery(
    queryReducers: Array<QueryReducer<mixed, mixed >> ,
    exeContext: ExecutionContext): Promise<ExecutionContext>;
declare function reduceType(
    exeContext: ExecutionContext,
    path: ResponsePath,
    type: GraphQLOutputType,
    selection: SelectionSetNode,
    queryReducers: Array<QueryReducer<mixed, mixed >> ,
    reductions: Array<mixed>): Array<mixed>;
/**
 * Given a ResponsePath (found in the `path` entry in the information provided
 * as the last argument to a field resolver), return an Array of the path keys.
 */
declare export function responsePathAsArray(path: ResponsePath): Array<string | number>;
declare function addPath(
    prev: ResponsePath,
    key: string | number): {
    prev: ResponsePath,
    key: string | number
};
/**
 * Builds the middleware context
 */
declare function buildMiddlewareContext(
    exeContext: ExecutionContext,
    middleware: Array<Middleware<mixed, mixed, mixed >> ): MiddlewareContext;
declare function runAfterQueryware(exeContext: ExecutionContext, middlewareContext: MiddlewareContext): void;
/**
 * Constructs a ExecutionContext object from the arguments passed to
 * execute, which we will pass throughout the other execution methods.

Throws a GraphQLError if a valid execution context cannot be created.
*/
declare function buildExecutionContext(
    schema: GraphQLSchema,
    document: DocumentNode,
    rootValue: mixed,
    contextValue: mixed,
    rawVariableValues: {
        [key: string]: mixed
    } | void,
    operationName: string | void): ExecutionContext;
/**
 * Implements the "Evaluating operations" section of the spec.
 */
declare function executeOperation(
    exeContext: ExecutionContext,
    operation: OperationDefinitionNode,
    rootValue: mixed,
    middlewareContext: MiddlewareContext): Promise<{
    [key: string]: mixed
}>| {
    [key: string]: mixed
};
/**
 * Extracts the root type of the operation from the schema.
 */
declare function getOperationRootType(schema: GraphQLSchema, operation: OperationDefinitionNode): GraphQLObjectType;
/**
 * Implements the "Evaluating selection sets" section of the spec
 * for "write" mode.
 */
declare function executeFieldsSerially(
    exeContext: ExecutionContext,
    parentType: GraphQLObjectType,
    sourceValue: mixed,
    path: ResponsePath,
    fields: {
        [key: string]: Array<FieldNode >
    },
    middlewareContext: MiddlewareContext): Promise<{
    [key: string]: mixed
}>;
/**
 * Implements the "Evaluating selection sets" section of the spec
 * for "read" mode.
 */
declare function executeFields(
    exeContext: ExecutionContext,
    parentType: GraphQLObjectType,
    sourceValue: mixed,
    path: ResponsePath,
    fields: {
        [key: string]: Array<FieldNode >
    },
    middlewareContext: MiddlewareContext): MaybePromise<{
    [key: string]: mixed
}>;
/**
 * Given a selectionSet, adds all of the fields in that selection to
 * the passed in map of fields, and returns it at the end.

CollectFields requires the "runtime type" of an object. For a field which
returns and Interface or Union type, the "runtime type" will be the actual
Object type returned by that field.
*/
declare function collectFields(
    exeContext: ExecutionContext,
    runtimeType: GraphQLObjectType,
    selectionSet: SelectionSetNode,
    fields: {
        [key: string]: Array<FieldNode >
    },
    visitedFragmentNames: {
        [key: string]: boolean
    }): {
    [key: string]: Array<FieldNode >
};
/**
 * Determines if a field should be included based on the @include and @skip
 * directives, where @skip has higher precidence than @include.
 */
declare function shouldIncludeNode(exeContext: ExecutionContext, directives: Array<DirectiveNode>): boolean;
/**
 * Determines if a fragment is applicable to the given type.
 */
declare function doesFragmentConditionMatch(
    exeContext: ExecutionContext,
    fragment: FragmentDefinitionNode | InlineFragmentNode,
    type: GraphQLObjectType): boolean;
/**
 * This function transforms a JS object `{[key: string]: Promise<T>}` into
 * a `Promise<{[key: string]: T}>`

This is akin to bluebird's `Promise.props`, but implemented only using
`Promise.all` so it will work with any implementation of ES6 promises.
*/
declare function promiseForObject<T>(object: {
    [key: string]: Promise<T >
}): Promise<{
    [key: string]: T
}>;
/**
 * Implements the logic to compute the key of a given field's entry
 */
declare function getFieldEntryKey(node: FieldNode): string;
/**
 * Resolves the field on the given source object. In particular, this
 * figures out the value that the field returns by calling its resolve function,
then calls completeValue to complete promises, serialize scalars, or execute
the sub-selection-set for objects.
*/
declare function resolveField(
    exeContext: ExecutionContext,
    parentType: GraphQLObjectType,
    source: mixed,
    fieldNodes: Array<FieldNode>,
    path: ResponsePath,
    middlewareContext: MiddlewareContext): mixed;
declare function resolveOrError<TSource, TContext>(
    exeContext: ExecutionContext,
    fieldDef: GraphQLField<TSource, TContext>,
    fieldNode: FieldNode,
    resolveFn: GraphQLFieldResolver<TSource, TContext>,
    source: TSource,
    context: TContext,
    info: GraphQLExtResolveInfo,
    middlewareContext: MiddlewareContext): Error | mixed;
declare function completeValueCatchingError(
    exeContext: ExecutionContext,
    returnType: GraphQLType,
    fieldNodes: Array<FieldNode>,
    info: GraphQLResolveInfo,
    path: ResponsePath,
    result: mixed,
    middlewareContext: MiddlewareContext): mixed;
declare function completeValueWithLocatedError(
    exeContext: ExecutionContext,
    returnType: GraphQLType,
    fieldNodes: Array<FieldNode>,
    info: GraphQLResolveInfo,
    path: ResponsePath,
    result: mixed,
    middlewareContext: MiddlewareContext): mixed;
/**
 * Implements the instructions for completeValue as defined in the
 * "Field entries" section of the spec.

If the field type is Non-Null, then this recursively completes the value
for the inner type. It throws a field error if that completion returns null,
as per the "Nullability" section of the spec.

If the field type is a List, then this recursively completes the value
for the inner type on each item in the list.

If the field type is a Scalar or Enum, ensures the completed value is a legal
value of the type by calling the `serialize` method of GraphQL type
definition.

If the field is an abstract type, determine the runtime type of the value
and then complete based on that type

Otherwise, the field type expects a sub-selection set, and will complete the
value by evaluating all sub-selections.
*/
declare function completeValue(
    exeContext: ExecutionContext,
    returnType: GraphQLType,
    fieldNodes: Array<FieldNode>,
    info: GraphQLResolveInfo,
    path: ResponsePath,
    result: mixed,
    middlewareContext: MiddlewareContext): mixed;
/**
 * Complete a list value by completing each item in the list with the
 * inner type
 */
declare function completeListValue(
    exeContext: ExecutionContext,
    returnType: GraphQLList<GraphQLType>,
    fieldNodes: Array<FieldNode>,
    info: GraphQLResolveInfo,
    path: ResponsePath,
    result: mixed,
    middlewareContext: MiddlewareContext): mixed;
/**
 * Complete a Scalar or Enum by serializing to a valid value, returning
 * null if serialization is not possible.
 */
declare function completeLeafValue(returnType: GraphQLLeafType, result: mixed): mixed;
/**
 * Complete a value of an abstract type by determining the runtime object type
 * of that value, then complete the value for that type.
 */
declare function completeAbstractValue(
    exeContext: ExecutionContext,
    returnType: GraphQLAbstractType,
    fieldNodes: Array<FieldNode>,
    info: GraphQLResolveInfo,
    path: ResponsePath,
    result: mixed,
    middlewareContext: MiddlewareContext): mixed;
declare function ensureValidRuntimeType(
    runtimeTypeOrName: GraphQLObjectType | string,
    exeContext: ExecutionContext,
    returnType: GraphQLAbstractType,
    fieldNodes: Array<FieldNode>,
    info: GraphQLResolveInfo,
    result: mixed): GraphQLObjectType;
/**
 * Complete an Object value by executing all sub-selections.
 */
declare function completeObjectValue(
    exeContext: ExecutionContext,
    returnType: GraphQLObjectType,
    fieldNodes: Array<FieldNode>,
    info: GraphQLResolveInfo,
    path: ResponsePath,
    result: mixed,
    middlewareContext: MiddlewareContext): mixed;
declare function invalidReturnTypeError(
    returnType: GraphQLObjectType,
    result: mixed,
    fieldNodes: Array<FieldNode>): GraphQLError;
declare function collectAndExecuteSubfields(
    exeContext: ExecutionContext,
    returnType: GraphQLObjectType,
    fieldNodes: Array<FieldNode>,
    _info: GraphQLResolveInfo,
    path: ResponsePath,
    result: mixed,
    middlewareContext: MiddlewareContext): mixed;
/**
 * If a resolveType function is not given, then a default resolve behavior is
 * used which tests each possible type for the abstract type by calling
isTypeOf for the object being coerced, returning the first type that matches.
*/
declare function defaultResolveTypeFn(
    value: mixed,
    context: mixed,
    info: GraphQLResolveInfo,
    abstractType: GraphQLAbstractType): MaybePromise<GraphQLObjectType>| void;
declare export var defaultFieldResolver: GraphQLFieldResolver<mixed, mixed>;
/**
 * Only returns the value if it acts like a Promise, i.e. has a "then" function,
 * otherwise returns void.
 */
declare function getPromise<T>(value: Promise<T>| mixed): Promise<T>| void;
/**
 * This method looks up the field on the given type defintion.
 * It has special casing for the two introspection fields, __schema
and __typename. __typename is special because it can always be
queried as a field, even in situations where no other fields
are allowed, like on a Union. __schema could get automatically
added to the query type, but that would require mutating type
definitions, which would cause issues.
*/
declare function getFieldDef(
    schema: GraphQLSchema,
    parentType: GraphQLObjectType,
    fieldName: string): GraphQLField<mixed, mixed>;